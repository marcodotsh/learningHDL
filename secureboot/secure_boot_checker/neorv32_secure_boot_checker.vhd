library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.neorv32_package.all;
use work.neorv32_secure_boot_checker_verification_image.all;
use work.neorv32_bootloader_image.all; -- this file is generated by the image generator
use work.neorv32_secure_boot_sha256_package.all;

entity neorv32_secure_boot_checker is
  port (
    clk_i      : in std_ulogic;
    rstn_i     : in std_ulogic;
    bus_req_o  : out bus_req_t;
    bus_rsp_i  : in bus_rsp_t;
    cpu_rstn_o : out std_ulogic
  );
end neorv32_secure_boot_checker;

architecture neorv32_secure_boot_checker_rtl of neorv32_secure_boot_checker is

  constant RSA_KEY_SIZE : integer := 512;
  -- determine physical ROM size in WORDS (expand to next power of two) --
  constant boot_rom_size_index_c : natural                         := index_size_f((bootloader_init_size_c/4)); -- address with (words)
  constant boot_rom_size_c       : natural range 0 to iodev_size_c := (2 ** boot_rom_size_index_c); -- physical size in words

  type state_t is (
    IDLE,
    READ_SIGNATURE_REQ,
    READ_SIGNATURE_RSP,
    START_RSA,
    READ_BOOTLOADER_LENGTH_REQ,
    READ_BOOTLOADER_LENGTH_RSP,
    START_HASHER,
    WAIT_FOR_COMPONENTS,
    CHECK_RESULTS,
    VALID_STATE,
    INVALID_STATE
  );

  signal current_state, next_state : state_t;

  -- RSA component signals
  signal rsa_start_reg    : std_ulogic;
  signal rsa_done_wire    : std_ulogic;
  signal rsa_base_reg     : std_ulogic_vector(RSA_KEY_SIZE - 1 downto 0); -- Now also serves as signature accumulator
  signal rsa_exponent_reg : std_ulogic_vector(19 downto 0);
  -- rsa_modulus_reg removed
  signal rsa_result_wire : std_ulogic_vector(RSA_KEY_SIZE - 1 downto 0);

  -- Hasher component signals
  signal hasher_start_reg         : std_ulogic;
  signal hasher_done_wire         : std_ulogic;
  signal hasher_words_to_read_reg : std_ulogic_vector(31 downto 0);
  signal hasher_hash_wire         : std_ulogic_vector(255 downto 0);

  -- Memory access signals
  signal addr_cnt_reg : natural range 0 to RSA_KEY_SIZE/32;
  -- signature_reg removed
  signal length_reg  : std_ulogic_vector(31 downto 0);
  signal bus_req_reg : bus_req_t;

  signal hasher_bus_req_wire : bus_req_t;

  signal cpu_rstn_reg : std_ulogic;

begin

  rsa_inst : entity work.neorv32_secure_boot_rsa
    generic map(
      RSA_KEY_SIZE => RSA_KEY_SIZE
    )
    port map
    (
      clk_i      => clk_i,
      rstn_i     => rstn_i,
      start_i    => rsa_start_reg,
      base_i     => rsa_base_reg,
      exponent_i => rsa_exponent_reg,
      modulus_i  => rsa_modulus_c, -- Directly use constant
      result_o   => rsa_result_wire,
      done_o     => rsa_done_wire
    );

  hasher_inst : entity work.neorv32_secure_boot_boot_rom_hasher
    port map
    (
      clk_i           => clk_i,
      rst_i           => rstn_i,
      start_i         => hasher_start_reg,
      words_to_read_i => hasher_words_to_read_reg,
      bus_rsp_i       => bus_rsp_i,
      bus_req_o       => hasher_bus_req_wire,
      done_o          => hasher_done_wire,
      hash_o          => hasher_hash_wire
    );

  process (clk_i, rstn_i)
  begin
    if rstn_i = '0' then
      current_state <= IDLE;
    elsif rising_edge(clk_i) then
      current_state <= next_state;
    end if;
  end process;

  process (current_state, rstn_i, bus_rsp_i, rsa_done_wire, hasher_done_wire, rsa_result_wire, hasher_hash_wire, addr_cnt_reg)
  begin
    next_state <= current_state;
    case current_state is
      when IDLE =>
        if rstn_i = '1' then
          next_state <= READ_SIGNATURE_REQ;
        end if;

      when READ_SIGNATURE_REQ =>
        next_state <= READ_SIGNATURE_RSP;

      when READ_SIGNATURE_RSP =>
        if bus_rsp_i.ack = '1' then
          if addr_cnt_reg = (RSA_KEY_SIZE/32) - 1 then
            next_state <= START_RSA;
          else
            next_state <= READ_SIGNATURE_REQ;
          end if;
        end if;

      when START_RSA =>
        next_state <= READ_BOOTLOADER_LENGTH_REQ;

      when READ_BOOTLOADER_LENGTH_REQ =>
        next_state <= READ_BOOTLOADER_LENGTH_RSP;

      when READ_BOOTLOADER_LENGTH_RSP =>
        if bus_rsp_i.ack = '1' then
          next_state <= START_HASHER;
        end if;

      when START_HASHER =>
        next_state <= WAIT_FOR_COMPONENTS;

      when WAIT_FOR_COMPONENTS =>
        if rsa_done_wire = '1' and hasher_done_wire = '1' then
          next_state <= CHECK_RESULTS;
        end if;

      when CHECK_RESULTS =>
        if rsa_result_wire(255 downto 0) = hasher_hash_wire then
          next_state <= VALID_STATE;
        else
          next_state <= INVALID_STATE;
        end if;

      when VALID_STATE =>
        next_state <= VALID_STATE;

      when INVALID_STATE =>
        next_state <= INVALID_STATE;

    end case;
  end process;

  process (clk_i, rstn_i)
  begin
    if rstn_i = '0' then
      cpu_rstn_reg             <= '1';
      rsa_start_reg            <= '0';
      hasher_start_reg         <= '0';
      addr_cnt_reg             <= 0;
      rsa_base_reg             <= (others => '0'); -- Initialize rsa_base_reg
      length_reg               <= (others => '0');
      bus_req_reg              <= req_terminate_c;
      rsa_exponent_reg         <= (others => '0');
      hasher_words_to_read_reg <= (others => '0');
    elsif rising_edge(clk_i) then
      case current_state is
        when IDLE =>
          cpu_rstn_reg <= '1';
          addr_cnt_reg <= 0;
          rsa_base_reg <= (others => '0'); -- Clear rsa_base_reg for new signature
          length_reg   <= (others => '0');
          bus_req_reg  <= req_terminate_c;

        when READ_SIGNATURE_REQ =>
          bus_req_reg.addr <= std_ulogic_vector(to_unsigned((boot_rom_size_c - (RSA_KEY_SIZE/32) - 1 + addr_cnt_reg) * 4, 32));
          bus_req_reg.stb  <= '1';

        when READ_SIGNATURE_RSP =>
          if bus_rsp_i.ack = '1' then
            bus_req_reg.stb                                                                                                      <= '0';
            rsa_base_reg(((RSA_KEY_SIZE/32) - 1 - addr_cnt_reg + 1) * 32 - 1 downto ((RSA_KEY_SIZE/32) - 1 - addr_cnt_reg) * 32) <= bus_rsp_i.data; -- Write directly to rsa_base_reg
            addr_cnt_reg                                                                                                         <= addr_cnt_reg + 1;
          end if;

        when START_RSA =>
          rsa_start_reg <= '1';
          -- rsa_base_reg is already loaded
          rsa_exponent_reg <= rsa_public_exponent_c;
          -- rsa_modulus_reg is directly connected
          addr_cnt_reg <= (RSA_KEY_SIZE/32); -- Reset for next read

        when READ_BOOTLOADER_LENGTH_REQ =>
          bus_req_reg.addr <= std_ulogic_vector(to_unsigned((boot_rom_size_c - (RSA_KEY_SIZE/32) - 1 + addr_cnt_reg) * 4, 32));
          bus_req_reg.stb  <= '1';

        when READ_BOOTLOADER_LENGTH_RSP =>
          if bus_rsp_i.ack = '1' then
            bus_req_reg.stb <= '0';
            length_reg      <= bus_rsp_i.data;
          end if;

        when START_HASHER =>
          hasher_start_reg         <= '1';
          hasher_words_to_read_reg <= length_reg;

        when WAIT_FOR_COMPONENTS =>
          null;

        when CHECK_RESULTS =>
          null;

        when VALID_STATE =>
          cpu_rstn_reg <= '0';

        when INVALID_STATE =>
          cpu_rstn_reg <= '1';
      end case;
    end if;
  end process;

  process (current_state, bus_req_reg, hasher_bus_req_wire)
  begin
    if current_state = READ_SIGNATURE_REQ or
      current_state = READ_SIGNATURE_RSP or
      current_state = READ_BOOTLOADER_LENGTH_REQ or
      current_state = READ_BOOTLOADER_LENGTH_RSP then
      bus_req_o <= bus_req_reg;
    else
      bus_req_o <= hasher_bus_req_wire;
    end if;
  end process;

  cpu_rstn_o <= cpu_rstn_reg;

end neorv32_secure_boot_checker_rtl;
